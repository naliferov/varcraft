<!DOCTYPE html>
<html data-version="1">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <link rel="icon" type="image/png" href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik03LjkwNDUxIDYuOTIxNDRDOC40MTM0MSA2LjQ1NDk1IDguNDQ3NzkgNS42NjQyNCA3Ljk4MTMgNS4xNTUzNEM3LjUxNDgxIDQuNjQ2NDUgNi43MjQxIDQuNjEyMDcgNi4yMTUyIDUuMDc4NTZMNy45MDQ1MSA2LjkyMTQ0Wk0xLjQ2MTk0IDExLjEzMTRMMi4zMDY2IDEyLjA1MjlMMi4zMDY2IDEyLjA1MjlMMS40NjE5NCAxMS4xMzE0Wk0xLjQ2MTk0IDExLjg2ODZMMi4zMDY2IDEwLjk0NzFMMi4zMDY2IDEwLjk0NzFMMS40NjE5NCAxMS44Njg2Wk02LjIxNTIgMTcuOTIxNEM2LjcyNDEgMTguMzg3OSA3LjUxNDgxIDE4LjM1MzYgNy45ODEzIDE3Ljg0NDdDOC40NDc3OSAxNy4zMzU4IDguNDEzNDEgMTYuNTQ1IDcuOTA0NTEgMTYuMDc4Nkw2LjIxNTIgMTcuOTIxNFpNNi4yMTUyIDUuMDc4NTZMMC42MTcyODcgMTAuMjFMMi4zMDY2IDEyLjA1MjlMNy45MDQ1MSA2LjkyMTQ0TDYuMjE1MiA1LjA3ODU2Wk0wLjYxNzI4NyAxMi43OUw2LjIxNTIgMTcuOTIxNEw3LjkwNDUxIDE2LjA3ODZMMi4zMDY2IDEwLjk0NzFMMC42MTcyODcgMTIuNzlaTTAuNjE3Mjg3IDEwLjIxQy0wLjEzOTM1NiAxMC45MDM2IC0wLjEzOTM1NiAxMi4wOTY0IDAuNjE3Mjg3IDEyLjc5TDIuMzA2NiAxMC45NDcxQzIuNjMwODcgMTEuMjQ0NCAyLjYzMDg3IDExLjc1NTYgMi4zMDY2IDEyLjA1MjlMMC42MTcyODcgMTAuMjFaIiBmaWxsPSIjMDAwMDAwIi8+DQo8cGF0aCBkPSJNMTYuMDU1NyAxNi4wNzg2QzE1LjU0NjggMTYuNTQ1IDE1LjUxMjUgMTcuMzM1OCAxNS45Nzg5IDE3Ljg0NDdDMTYuNDQ1NCAxOC4zNTM2IDE3LjIzNjEgMTguMzg3OSAxNy43NDUgMTcuOTIxNEwxNi4wNTU3IDE2LjA3ODZaTTIyLjQ5ODMgMTEuODY4NkwyMS42NTM3IDEwLjk0NzFMMjEuNjUzNyAxMC45NDcxTDIyLjQ5ODMgMTEuODY4NlpNMjIuNDk4MyAxMS4xMzE0TDIxLjY1MzcgMTIuMDUyOUwyMS42NTM3IDEyLjA1MjlMMjIuNDk4MyAxMS4xMzE0Wk0xNy43NDUgNS4wNzg1NkMxNy4yMzYxIDQuNjEyMDcgMTYuNDQ1NCA0LjY0NjQ1IDE1Ljk3OSA1LjE1NTM0QzE1LjUxMjUgNS42NjQyNCAxNS41NDY4IDYuNDU0OTUgMTYuMDU1NyA2LjkyMTQ0TDE3Ljc0NSA1LjA3ODU2Wk0xNy43NDUgMTcuOTIxNEwyMy4zNDMgMTIuNzlMMjEuNjUzNyAxMC45NDcxTDE2LjA1NTcgMTYuMDc4NkwxNy43NDUgMTcuOTIxNFpNMjMuMzQzIDEwLjIxTDE3Ljc0NSA1LjA3ODU2TDE2LjA1NTcgNi45MjE0NEwyMS42NTM3IDEyLjA1MjlMMjMuMzQzIDEwLjIxWk0yMy4zNDMgMTIuNzlDMjQuMDk5NiAxMi4wOTY0IDI0LjA5OTYgMTAuOTAzNiAyMy4zNDMgMTAuMjFMMjEuNjUzNyAxMi4wNTI5QzIxLjMyOTQgMTEuNzU1NiAyMS4zMjk0IDExLjI0NDQgMjEuNjUzNyAxMC45NDcxTDIzLjM0MyAxMi43OVoiIGZpbGw9IiMwMDAwMDAiLz4NCjxwYXRoIGQ9Ik0xNS4yMTI3IDMuODAzMTdDMTUuMzgwMSAzLjEzMzQzIDE0Ljk3MjkgMi40NTQ3NiAxNC4zMDMyIDIuMjg3MzJDMTMuNjMzNCAyLjExOTg5IDEyLjk1NDggMi41MjcwOSAxMi43ODczIDMuMTk2ODNMMTUuMjEyNyAzLjgwMzE3Wk04Ljc4NzMyIDE5LjE5NjhDOC42MTk4OSAxOS44NjY2IDkuMDI3MDkgMjAuNTQ1MiA5LjY5NjgzIDIwLjcxMjdDMTAuMzY2NiAyMC44ODAxIDExLjA0NTIgMjAuNDcyOSAxMS4yMTI3IDE5LjgwMzJMOC43ODczMiAxOS4xOTY4Wk0xMi43ODczIDMuMTk2ODNMOC43ODczMiAxOS4xOTY4TDExLjIxMjcgMTkuODAzMkwxNS4yMTI3IDMuODAzMTdMMTIuNzg3MyAzLjE5NjgzWiIgZmlsbD0iIzAwMDAwMCIvPg0KPC9zdmc+">
        <title>varcraft</title>
    </head>
    <body>
        <script type="module">

document.body.style.margin = 0
// window.addEventListener('beforeunload', (e) => {
//     e.preventDefault()
//     e.returnValue = ''
//     //run saving html
//     //console.log('beforeunload')
// })

const symbolRepository = Symbol('repository')

const mk = (id, target, tag = 'div') => {
  const el = document.createElement(tag)
  if (id) {
    if (id[0] === '.') {
      el.className = id.slice(1)
    } else {
      el.id = id
    }
  }
  target.append(el)
  return el
}

const ulid = (() => {
  const ENCODING = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
  const ENCODING_LEN = ENCODING.length;
  const TIME_LEN = 10;
  const RANDOM_LEN = 16;
  const TIME_MAX = Math.pow(2, 48) - 1;

  let lastTime = 0;
  let lastRandom = '';

  function getPRNG(allowInsecure) {
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
      return () => {
        const buf = new Uint8Array(1);
        crypto.getRandomValues(buf);
        return buf[0] / 0xff;
      };
    }
    if (allowInsecure) {
      return () => Math.random();
    }
    throw new Error('secure crypto unavailable');
  }

  function randChar(rng) {
    let r = Math.floor(rng() * ENCODING_LEN);
    if (r === ENCODING_LEN) r = ENCODING_LEN - 1;
    return ENCODING[r];
  }

  function encodeTime(ms) {
    if (!Number.isInteger(ms) || ms < 0 || ms > TIME_MAX) {
      throw new Error('invalid time');
    }
    let str = '';
    for (let i = 0; i < TIME_LEN; i++) {
      str = ENCODING[ms % ENCODING_LEN] + str;
      ms = Math.floor(ms / ENCODING_LEN);
    }
    return str;
  }

  function encodeRandom(rng) {
    let str = '';
    for (let i = 0; i < RANDOM_LEN; i++) {
      str = randChar(rng) + str;
    }
    return str;
  }

  function increment(str) {
    const arr = str.split('');
    for (let i = arr.length - 1; i >= 0; i--) {
      const idx = ENCODING.indexOf(arr[i]);
      if (idx < 0) throw new Error('invalid random component');
      if (idx < ENCODING_LEN - 1) {
        arr[i] = ENCODING[idx + 1];
        return arr.join('');
      }
      arr[i] = ENCODING[0];
    }
    throw new Error('cannot increment');
  }

  return function({ monotonic = false, allowInsecure = false, prng, time } = {}) {
    const ms = Number.isInteger(time) ? time : Date.now();
    const rng = prng || getPRNG(allowInsecure);

    if (monotonic) {
      if (ms <= lastTime) {
        lastRandom = increment(lastRandom);
      } else {
        lastTime = ms;
        lastRandom = encodeRandom(rng);
      }
      return encodeTime(lastTime) + lastRandom;
    }

    return encodeTime(ms) + encodeRandom(rng);
  };
})();

const app = mk('app', document.body)
app.style.display = 'flex'

const head = document.head
const fontUrl = 'https://fonts.googleapis.com/css2?family';
[
  `${fontUrl}=Roboto:wght@400;700&display=swap`,
  `${fontUrl}=JetBrains+Mono:wght@400;700&display=swap`
].forEach(url => {
  const link = document.createElement('link')
  link.rel = 'stylesheet'
  link.href = url
  head.appendChild(link)
})

const { promise: editorIsReady, resolve: editorIsReadyResolve } = Promise.withResolvers()
const requireScript = document.createElement('script');
requireScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js'
requireScript.onload = () => {
    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs' } })
    require(['vs/editor/editor.main'], editorIsReadyResolve)
}
head.append(requireScript)
await editorIsReady

const objectBrowserWidth = 250
const objectBrowserPadding = 8
let objectBrowser = mk('object-browser', app)
objectBrowser.style.width = objectBrowserWidth + 'px'
objectBrowser.style.height = window.innerHeight - objectBrowserPadding * 2 + 'px'
objectBrowser.style.padding = objectBrowserPadding + 'px'

objectBrowser = objectBrowser.attachShadow({mode: 'open'})
const style = mk(0, objectBrowser, 'style')
style.textContent = `
  :host {
    display: block;
    background: #f3f3f3;
    color: #616161;
    font-family: Roboto, monospace;
  }
  .object-browser-section {
    margin-bottom: 0.5em;
  }
  .object-browser-header {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .op-list-btn {
    width: 24px;
    height: 24px;
    cursor: pointer;
  }
  .object {
    cursor: pointer;
  }
  .object:hover:not(:has(.object:hover)) {
    background:rgb(229, 229, 229);
  }
`

const objectBrowserHeader = mk('.object-browser-header', objectBrowser)
mk(0, objectBrowser, 'br')

const opListBtn = mk('.op-list-btn', objectBrowserHeader)
opListBtn.innerHTML = `
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="size-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
  </svg>
`

const opListManager = {
  opList: null,
  createOpList() {
    if (this.opList) {
      this.removeOpList()
      return
    }
    this.opList = mk('.op-list', app)
    const style = mk(null, this.opList, 'style')
    style.innerHTML = `
      .op-list {
        min-width: 10em;
        position: absolute;
        background: #f3f3f3;
        color: #616161;
        font-family: Roboto, sans-serif;
        box-shadow: rgba(2, 0, 0, 0.35) 0px 5px 15px;
        cursor: pointer;
        z-index: 1000;
      }
      .op-list-item {
        padding: 5px;
      }
        .op-list-item:hover {
        background:rgb(221, 221, 221);
      }          
    `
    return this.opList
  },
  removeOpList() {
    this.opList.remove()
    this.opList = null
  }
}

const opListBtnRect = opListBtn.getBoundingClientRect()
opListBtn.addEventListener('click', (e) => {
  const opList = opListManager.createOpList()
  if (!opList) return

  opList.style.left = `${opListBtnRect.left}px`
  opList.style.top = `${opListBtnRect.top + opListBtnRect.height}px`

  const importDump = async (db, file) => {
    const r = new FileReader()
    r.readAsText(file)
    r.onload = async () => {      
      const objects = JSON.parse(r.result)
      for (const object of objects) {
        console.log(object)
        //await systemObjectsRepository.setObject(object.id, object)
      }
      console.log('import complete')
    }
  }

  const exportDump = async (db) => {
    if (inProgress) return
    inProgress = true

    const { pgDump } = await import('https://cdn.jsdelivr.net/npm/@electric-sql/pglite-tools/dist/pg_dump.js')
    const dump = await pgDump({ pg: db })

    const a = document.createElement('a')
    a.href = URL.createObjectURL(dump)
    a.download = dump.name
    a.click()
    URL.revokeObjectURL(a.href)

    inProgress = false
  }

  const itemSystemImport = mk('.op-list-item', opList)
  itemSystemImport.textContent = 'Import system objects'

  let fInput = mk(null, itemSystemImport, 'input')
  fInput.type = 'file'
  fInput.style.marginLeft = '10px'
  fInput.addEventListener('change', async(e) => {
    const file = e.target.files[0]
    if (!file) return    
    importDump(dbSystem, file)
  })

  let inProgress = false

  const itemSystemExport = mk('.op-list-item', opList)
  itemSystemExport.textContent = 'Export system objects'
  itemSystemExport.addEventListener('click', async () => {
    exportDump(dbSystem)
  })

  const itemUserImport = mk('.op-list-item', opList)
  itemUserImport.textContent = 'Import user objects'

  fInput = mk(null, itemUserImport, 'input')
  fInput.type = 'file'
  fInput.style.marginLeft = '10px'
  fInput.addEventListener('change', async (e) => {
    const file = e.target.files[0]
    if (!file) return    
    await dbDropTables(dbUser)
    await importDump(dbUser, file)
  })

  const itemUserExport = mk('.op-list-item', opList)
  itemUserExport.textContent = 'Export user objects'
  itemUserExport.addEventListener('click', (e) => {
    e.preventDefault()
    exportDump(dbUser)
  })
})

const objectBrowserHeading = mk(0, objectBrowserHeader)
objectBrowserHeading.textContent = 'EXPLORER'

objectBrowser.systemSection = mk('object-browser-system-section', objectBrowser)
objectBrowser.systemSection.className = 'object-browser-section'

let sectionHeading = mk(0, objectBrowser.systemSection)
sectionHeading.textContent = 'System:'
sectionHeading.style.fontWeight = 'bold'

objectBrowser.userSection = mk('object-browser-user-section', objectBrowser)
objectBrowser.userSection.className = 'object-browser-section'

sectionHeading = mk(0, objectBrowser.userSection)
sectionHeading.textContent = 'User:'
sectionHeading.style.fontWeight = 'bold'

const createTabManager = (target, mk, width) => {

  const tabsContainer = mk('tabs-container', target)
  tabsContainer.style.width = width
  const style = mk(null, tabsContainer, 'style')
  style.innerHTML = `
    #tabs-bar {
      display: flex;
      background: #f3f3f3;
    }
    .tab {
      display: flex;
      align-items: center;
      padding: 8px;
      cursor: pointer;
      background: #e4e4e4;
    }
    .tab.active {
      background: #FFFFFF;
    }
    .tab-name {
      font-family: Roboto, sans-serif;
      margin-right: 3px;
      color: #333333;
    }
    .tab-view.hidden {
      display: none;
    } 
    .object-code {
      font-family: 'JetBrains Mono', monospace;
    }
    #close-tab-btn {
      width: 18px;
      height: 18px;
      stroke: currentColor;
    }
  `
  
  const tabsBar = mk('tabs-bar', tabsContainer)
  const tabsBarHeight = 35
  const tabsView = mk('tabs-view', tabsContainer)
  tabsView.style.height = window.innerHeight - tabsBarHeight + 'px' 
  tabsView.style.overflow = 'scroll'

  let activeTab

  const openTab = (object) => {
    const tab = mk(null, tabsBar)
    tab.className = 'tab active'
    tab.setAttribute('object-id', object.id)

    tab.name = mk(null, tab)
    tab.name.className = 'tab-name'
    tab.name.textContent = object.data.name
    
    tab.closeBtn = mk('close-tab-btn', tab)
    tab.closeBtn.addEventListener('click', (e) => {
      e.stopPropagation()

      let tabForActivation

      if (tab === activeTab.tab) {
        const tabs = tabsBar.children
        const tabIndex = Array.from(tabs).indexOf(tab)
        const nextTab = tabIndex > 0 
          ? tabs[tabIndex - 1]
          : tabs[tabIndex + 1];

        if (nextTab) {
          tabForActivation = { 
            tab: nextTab,
            tabView: nextTab.view 
          }
        }
      }

      closeTab({ tab, tabView: tab.view })
      //todo add second param as source which opened object before, in this case it's tabManager
      objectManager.closeObject(object, 'tabManager')

      if (tabForActivation) {
        activateTab(tabForActivation)
        saveActiveTab(tabForActivation.tab.getAttribute('object-id'))
      } else {
        clearActiveTab()
      }
    })
    tab.closeBtn.innerHTML += `
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12"></path>
      </svg>
    `
    tab.view = mk('.tab-view', tabsView)

    const pre = mk('object-code', tab.view, 'div')
    pre.style.height = window.innerHeight - tabsBarHeight + 'px' 

    const editor = monaco.editor.create(pre, {
      value: object.data.code, 
      language: 'javascript',
      theme: 'vs-dark', 
      automaticLayout: true, 
      fontSize: 15
    })

    const openedObjects = objectManager.getOpenedObjects()
    const pos = openedObjects[object.id]
    if (pos && typeof pos === 'object') editor.revealPositionInCenter(pos)

    editor.onDidChangeModelContent((e) => {
      if (!object.id) return
      
      const pos = editor.getPosition()
      objectManager.openObject(object, pos)
      object.data.code = editor.getValue()

      systemObjectsRepository.setObject(object.id, object)
    })

    const tabForActivation = { tab, tabView: tab.view }
    tab.addEventListener('click', () => {
      activateTab(tabForActivation)
      saveActiveTab(object.id)
    })
    activateTab(tabForActivation)

    return tabForActivation
  }

  const closeTab = (tabForDeactivation) => {
    const { tab, tabView } = tabForDeactivation
    tab.remove()
    tabView.remove()
  }

  const activateTab = (tabForActivation) => {
    if (activeTab) {
      const { tab, tabView } = activeTab
      tab.classList.remove('active')
      tabView.classList.add('hidden')
    }

    const { tab, tabView } = tabForActivation
    
    tab.classList.add('active')
    tabView.classList.remove('hidden')
    activeTab = tabForActivation
  }

  const saveActiveTab = (id) => kvRepository.setKey('activeTabId', id)
  const clearActiveTab = () => kvRepository.delKey('activeTabId')

  const restoreLastActiveTab = async () => {
    const value = await kvRepository.getKey('activeTabId')
    if (!value) return

    const tab = tabsBar.querySelector(`[object-id="${value}"]`)
    const tabView = tab.view
    if (tab && tabView) {
      activateTab({ tab, tabView })
    }
  }

  return { openTab, saveActiveTab, restoreLastActiveTab }
}

const tabManagerWidth = `calc(100% - ${objectBrowserWidth + objectBrowserPadding * 2}px)`
const tabManager = createTabManager(app, mk, tabManagerWidth)
//const objectsView = mk('objects-view', app)

class IndexedDb {  
  async open(dbName = 'default', storages = ['default']) {
    return new Promise((resolve, reject) => {
      const openRequest = indexedDB.open(dbName)
      
      openRequest.onerror = () => {
        reject(openRequest.error)
      }
      openRequest.onsuccess = () => {
        this.db = openRequest.result
        resolve(this.db)
      }
      openRequest.onupgradeneeded = () => {
        const db = openRequest.result
        
        for (const storageName of storages) {
          if (!db.objectStoreNames.contains(storageName)) {
            db.createObjectStore(storageName)
          }
        }
      }
    })
  }
  async set(x) {
    const { storeName = 'default', id, value } = x

    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(value, id)
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async get(x) {
    const { storeName = 'default', id } = x

    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).get(id)
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async getAll(x) {
    const { storeName = 'default' } = x
    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readonly').objectStore(storeName).getAll()
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
  async del(x) {
    const { storeName = 'default', id } = x

    return new Promise((resolve, reject) => {
      const rq = this.db.transaction(storeName, 'readwrite').objectStore(storeName).delete(id)
      rq.onsuccess = () => resolve(rq.result)
      rq.onerror = () => reject(rq.error)
    })
  }
}

const dbSystem = null
const dbUser = null

const idbSys = new IndexedDb()
await idbSys.open('sys', ['objects'])
const idbUser = new IndexedDb()
await idbUser.open('user', ['objects', 'kv'])

const baseRepository = {
  db: null,
  table: null,
  init(db) { 
    this.db = db
  },
  async getById(id) {
    return await this.db.get({ storeName: this.table, id })
  },
}

const createRepository = (child) => Object.assign(Object.create(baseRepository), child)

const createObjectsRepository = (child = {}) => createRepository({
  table: 'objects',
  async getAll() {
    return await this.db.getAll({ storeName: this.table })
  },
  async setObject(id, object) { 
    await this.db.set({ storeName: this.table, id, value: object }) 
  },
  async updateObjectData(objectId, data) {
    await this.db.query(`UPDATE public.${this.table} SET data = $1 WHERE id = $2`, [data, objectId])
  },
  async getNextObjects(objectId) {
    let oId = objectId
    if (oId === 'main') oId = 'main'.padEnd(26, ' ')

    const object = await this.db.get({ storeName: this.table, id: oId })
    if (!object || !object.next_id) return []
    
    const objects = []

    let currentId = object.next_id
    while (currentId) {
      const object = await this.db.get({ storeName: this.table, id: currentId })
      if (!object) { 
        console.warn(`No record found with id=${currentId}`)
        break
      }
      objects.push(object)
      currentId = object.next_id
    }
    return objects
  },

  ...child
})

const systemObjectsRepository = createObjectsRepository()
systemObjectsRepository.init(idbSys)
const userObjectsRepository = createObjectsRepository()
userObjectsRepository.init(idbUser)

const kvRepository = createRepository({
  table: 'kv',
  async getKey(key) {
    return await this.db.get({ storeName: this.table, id: key })
  },
  async setKey(key, value) {
    await this.db.set({ storeName: this.table, id: key, value })
  },
  async delKey(key) {
    await this.db.del({ storeName: this.table, id: key })
  }
})
kvRepository.init(idbUser)

const objectManager = {
  openedObjectsIds: {},
  async init() {
    const v = await kvRepository.getKey('openedObjectsIds')
    if (v) this.openedObjectsIds = v
  },
  getOpenedObjects() {
    return this.openedObjectsIds
  },
  isObjectOpened(objectId) {
    return Boolean(this.openedObjectsIds[objectId])
  },
  openObject(object, pos) {
    this.openedObjectsIds[object.id] = pos ? pos : 1
    this.saveOpenedObjects()
  },
  openObjectWithObject(object, otherObject) {},
  closeObject(object) {
    delete this.openedObjectsIds[object.id]
    this.saveOpenedObjects()
  },
  saveOpenedObjects() {
    kvRepository.setKey('openedObjectsIds', this.openedObjectsIds)
  },
}
const renderObjectName = (object, target, repo = 'sys') => {
  const dom = mk(object.id, target)
  dom.className = `object repo-${repo}`

  dom.name = mk(null, dom)
  dom.name.innerText = object.data.name
  dom.name.addEventListener('click', async (e) => {
    if (objectManager.isObjectOpened(object.id)) return
    tabManager.openTab(object)
    tabManager.saveActiveTab(object.id)
    objectManager.openObject(object)
  })
  dom.name.addEventListener('contextmenu', (e) => {
    e.preventDefault()
    e.stopPropagation()
    const opListTarget = e.target.parentElement

    const opList = opListManager.createOpList()
    if (!opList) return
    opList.style.left = `${e.clientX}px`
    opList.style.top = `${e.clientY}px`

    const mkOp = (text) => {
      let i = mk(null, opList)
      i.className = 'op-list-item'
      i.textContent = text
      return i
    }

    let i = mkOp('New Object')
    i.addEventListener('click', async (e) => {
      opListManager.removeOpList()

      const children = dom.getElementsByClassName('children')[0]
      if (!children || !children.children.length) return

      const last = children.children[children.children.length - 1]
      const lastObject = repo === 'sys'
        ? await systemObjectsRepository.getById(last.id)
        : await userObjectsRepository.getById(last.id)
      
      const newObject = {
        id: ulid(),
        data: { name: 'New Object', code: 'const { object } = $' },
        prev_id: last.id, next_id: null,
      }
      lastObject.next_id = newObject.id

      await Promise.all([
        systemObjectsRepository.setObject(lastObject.id, lastObject),
        systemObjectsRepository.setObject(newObject.id, newObject),
      ])
      renderObjectName(newObject, children)
    })

    i = mkOp('New Category')
    i.addEventListener('click', async (e) => {
        //console.log(object)
    })

    i = mkOp('Info')
    i.addEventListener('click', () => {
      console.log(object)
    })

    i = mkOp('Rename')
    i.addEventListener('click', () => {
      opListManager.removeOpList()
      dom.name.contentEditable = true
      dom.name.focus()

      const originalName = dom.name.textContent
      const handleRename = async () => {
        dom.name.contentEditable = false
        const newName = dom.name.textContent.trim()
        if (!newName || newName === originalName) {
            dom.name.textContent = originalName
            return
        }
        object.data.name = newName
        const repoObject = repo === 'sys' ? await systemObjectsRepository : await userObjectsRepository
        await repoObject.setObject(object.id, object)
      }

      const onKeyDown = async (e) => {
        if (e.key === 'Enter') {
          e.preventDefault()
          await handleRename()
          dom.name.removeEventListener('keydown', onKeyDown)
        }
        if (e.key === 'Escape') {
          dom.name.contentEditable = false
          dom.name.textContent = originalName
          dom.name.removeEventListener('keydown', onKeyDown)
        }
      }

      dom.name.addEventListener('keydown', onKeyDown)
    })
    i = mkOp('Delete')
    i.addEventListener('click', () => {
      //tabManager.openTab(object)
    })
  })

  const children = mk(null, dom)
  children.className = 'children'
  children.style.marginLeft = '1em'

  return { objectDom: dom, children }
}
const runObjectCode = async (x) => {
  const { object, objectBrowser, objectManager, tabManager, 
    renderObjectName, systemObjectsRepository, userObjectsRepository } = x
  const code = `export default async ($) => { 
    ${object.data.code}
  }`
  const blob = new Blob([code], { type: 'application/javascript' })
  try {
    const m = (await import(URL.createObjectURL(blob)))
    m.default({ 
      o: object, objectBrowser, objectManager, tabManager, renderObjectName, 
      systemObjectsRepository, userObjectsRepository
    })
  } catch (e) {
    console.error(e)
  }
}

await objectManager.init()

// for (const object of await systemObjectsRepository.getAll()) {
//     await idbSys.set({ storeName: 'objects', id: object.id, value: object })
// }

const mainObject = await systemObjectsRepository.getById('main'.padEnd(26, ' '))
if (!mainObject) {
    //get dump from backend
}

await renderObjectName(mainObject, objectBrowser.systemSection, 'sys')
await runObjectCode({
  object: mainObject, objectBrowser, 
  objectManager, tabManager, renderObjectName,
  systemObjectsRepository, userObjectsRepository
})

//actually objects opened by tabManager
const openedObjects = await objectManager.getOpenedObjects()

const isMainFound = Object.keys(openedObjects).find(id => id.trim() === 'main')
if (isMainFound) tabManager.openTab(mainObject)

        </script>
    </body>
</html>